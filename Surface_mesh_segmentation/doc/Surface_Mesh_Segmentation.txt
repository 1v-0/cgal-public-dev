namespace CGAL {
/*!
\mainpage Surface Mesh Segmentation

\author Ilker O. Yaz

\anchor Figure-1
\image latex elephant_sdf_partition.png "Figure 1: Elephant model with SDF values & Segmentation." width=12cm
\image html elephant_sdf_partition.png "Figure 1: Elephant model with SDF values & Segmentation."

# Introduction #
Mesh segmentation is the process of partitioning a mesh into smaller and meaningful sub-meshes. The application domain is wide and includes,
but is not limited to modeling, rigging and texturing, shape-retrieval, and deformation.

This package provides an implementation of the algorithm presented in \cite shapira2008consistent. It relies on the Shape Diameter Function (SDF) which
provides an estimate of the local volume diameter for each facet of the mesh. Given SDF values, the segmentation algorithm first applies soft clustering on
facets. These clusters are then refined using a graph-cut algorithm which also considers surface-based features such as dihedral-angle and concavity. 

The API gives access to both the SDF computation and segmentation for a given triangulated mesh. 
That way an alternative implementation of the SDF can be directly plug into the segmentation algorithm.

# Overview of the Segmentation Process #
The segmentation algorithm consists of three major parts: Shape Diameter Function (SDF), soft clustering, and graph-cut for hard clustering.

## Shape Diameter Function ##
The Shape Diameter Function (SDF) provides a connection between the surface and its volume. 
More precisely, the SDF is a scalar-valued function defined on the surface which measures the corresponding local volume diameter. 
The main handiness of the SDF is being able to distinguish thick and thin parts of the mesh by bringing in a volume-based feature to the surface. 
Another key feature of the SDF is its pose-invariant nature, which means that SDF values remains largely unaffected after changes of pose \ref Figure-2.

The SDF over a surface is computed by processing each facets one by one. For a given facet, the SDF value computation begins with casting
several rays sampled from a cone which is constructed using the centroid of the facet as apex and inward-normal of the facet as axis. 
Using these casted rays (which intuitively correspond to a local volume sampling), 
the SDF value is calculated by first applying outlier removal and then taking weighted average of ray lengths.

After calculating SDF values for each facet, bilateral smoothing (an edge-preserving filtering technique) is applied. 
The purpose of edge-preserving smoothing is removing noise while keeping fast changes on SDF values in-place without smoothing,
since they are natural candidates for segment boundaries.

\anchor Figure-2
\image latex pose_changes_low.png "Figure 2: Effect of pose changes on segmentation." width=12cm
\image html pose_changes_low.png "Figure 2: Effect of pose changes on segmentation."

## Soft Clustering ##
The soft clustering on computed SDF values first groups facets using k-means clustering algorithm which is initialized with k-means++
(an algorithm for choosing random seeds for clusters) and run multiple times. Among these runs, we choose clustering result that has minimum with-in
cluster error and use it to initialize expectation maximization algorithm for fitting Gaussian mixture models.

Note that there is no direct relationship between the number of clusters (parameter for soft clustering) and the number of segments (disconnected components). 
Intuitively, the number of clusters represents the number of levels of a segmentation by clustering facets which have close SDF values
without considering their connectivity.  However, a large number of clusters is likely to result in detailed segmentation of the mesh 
with a large number of segments \ref Figure-3.

The output of this step is a matrix that contains probability values for each facet to belong to each cluster. 
These probability values are used as input in the graph-cut step that follows.

\anchor Figure-3
\image latex effect_of_levels.png "Figure 3: Effect of the number of clusters on the segmentation. Number of clusters were set to 4, 3, and 2 respectively." width=12cm
\image html effect_of_levels.png "Figure 3: Effect of the number of clusters on the segmentation. Number of clusters were set to 4, 3, and 2 respectively."

## Graph-Cut ##
The final hard clustering, which gives the final partitioning of the mesh, is obtained by minimizing an energy function. 
This energy function combines the aforementioned probability matrix and geometric surface features.

The expression of energy function that is minimized using alpha-expansion graph cut algorithm is the following:

  <table border="0"> 
  <tr> 
	 <td>
		\f$ E(\bar{x}) = \sum\limits_{f \in F} e_1(f, x_f) + \lambda \sum\limits_{ \{f,g\} \in N} e_2(x_f, x_g) \f$

		\f$ e_1(f, x_f) = -log(max(P(f|x_f), \epsilon)) \f$

		\f$ e_2(x_f, x_g) = 
		\left \{ 
		\begin{array}{rl}
			-log(\theta(f,g)/\pi) &\mbox{ $x_f \ne x_g$} \\
			0 &\mbox{ $x_f = x_g$}
		\end{array}
		\right \} \f$
	 </td> 
     <td>	 
where:
  - \f$F\f$ is the set of facets, 
  - \f$N\f$ is the set of pairs of neighbor facets,
  - \f$x_f\f$ is the cluster assigned to facet \f$f\f$, 
  - \f$P(f|x_p)\f$ is the probability of assigning facet \f$f\f$ to cluster \f$x_p\f$, 
  - \f$\theta(f,g)\f$ is the dihedral angle between neighbor facets \f$f\f$, and \f$g\f$,
  - \f$\epsilon\f$ is the minimal probability threshold,
  - \f$\lambda \in [0,1]\f$ is a smoothness parameter.
	 </td> 
  </tr> 
  </table> 

The first term of the energy function provides the contribution of the soft clustering probabilities.
The second term of the energy function is larger when two neighbor facets sharing a sharp edge are in the same cluster. The smoothness parameter can be used
to make this geometric criteria more or less prevalent.

# API #
This package provides three functions:
	- CGAL::sdf_values_computation : computes SDF values as described in the original paper.
	- CGAL::surface_mesh_segmentation_from_sdf_values : computes the mesh segmentation from SDF values.
	- CGAL::surface_mesh_segmentation : computes SDF values and mesh segmentation in one go (i.e. combines two functions listed above).	

These functions expects a manifold triangulated polyhedron without boundary as input. Note that the current implementation is working with
polyhedron with boundaries, but considering how the SDF value are computed, using a polyhedron with large holes is likely to result in 
meaningless SDF values, and therefore unreliable segmentation.

The current implementation of the computation of the SDF values is relies on the AABB_tree package. 
This operation is robust when the AABBTraits model provides has exact predicates.
	
##The SDF Computation##
The function CGAL::sdf_values_computation provides an implementation of the SDF computation for a given `CGAL Polyhedron`. 

After computation, the following post-processing steps are applied:
  - Facets with no SDF values (i.e. zero) are assigned to average SDF value of its neighbors. If still there is any facet which has no SDF value, minimum SDF value greater than zero is assigned to it.
  - Smoothed with bilateral filtering.
  - Linearly normalized between [0,1].
  
The outputs are a property map which associates every facet with its SDF value, and pair of minimum and maximum SDF values before linear normalization.

###Example####
\include Surface_mesh_segmentation/sdf_values_computation_example.cpp

##Surface Mesh Segmentation##
The function CGAL::surface_mesh_segmentation_from_sdf_values computes a segmentation of the mesh using provided SDF values.
The outputs are number of segments and a property map which associates a segment-id (an integer between [0, number of segments -1]) to each facet. 
Formally, a segment is a set of connected facets which are placed under same cluster after graph-cut. 

###Example###
\include Surface_mesh_segmentation/surface_mesh_segmentation_from_sdf_values_example.cpp

The function CGAL::surface_mesh_segmentation combines the two aforementioned functions. 
Note that for segmenting the mesh several times with different parameters (i.e. number of levels, and smoothing lambda), 
it is wise to first compute the SDF values using CGAL::sdf_values_computation, and then call CGAL::surface_mesh_segmentation_from_sdf_values with the same SDF values.

###Example###
\include Surface_mesh_segmentation/surface_mesh_segmentation_example.cpp

##Using a polyhedron with an id per facet##
The previous examples use a `std::map` as property maps for storing the sdf values and the segmentation results. This example uses
a polyhedron type with a facet type having an extra id field together with a vector as underlying data structure in the property maps.
The main advantage is to decrease the complexity of accessing associated data with facets from logarithmic to constant. 

###Example###
\include Surface_mesh_segmentation/surface_mesh_segmentation_with_facet_ids_example.cpp

# Implementation history#
The initial implementation of this package is the result of the work of the author during the 2012 season
of the Google Summer of Code.

*/ 
} /* namespace CGAL */