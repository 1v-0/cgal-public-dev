namespace CGAL {

/*!
\mainpage 2D Visibility  
\anchor Chapter_2D_Visibility_Computation
\cgalAutoToc

\authors Michael Hemmer, Kan Huang, Francisc Bungiu

\section visibility_2_introduction Introduction

\cgalFigureBegin{example_figure,visibility-teaser.png}
An example figure. 
\cgalFigureEnd

This package provides functionality to compute the visibility area within polygonal regions in two dimensions. 
Let \f$ P \f$ be a regular polygon, i.e. with \f$ \partial P = \partial(P\setminus\partial P)\f$ and \f$\partial P \subset P\f$,
where  \f$\partial P \f$ denotes the boundary of \f$ P \f$.
\f$ P \f$ may have holes or can be simple. 
Given two points \f$ p \f$ and \f$ q \f$ in \f$ P \f$, they are said to be visible to each other iff the segment 
\f$ pq \subset  P \f$. 
The set of points that are visible from \f$ q \f$ is defined as the visibility region of \f$ q \f$, denote by \f$ V_q \f$.  

\section visibility_2_degeneracies Degeneracies and Regularization 

\cgalFigureBegin{definition-fig, example1.png}
Non-regularized visibility and regularized visibility.
\cgalFigureEnd


As demonstrated \cgalFigureRef{definition-fig} (1) the visibility region \f$ V_q \f$ of a query point \f$ q \f$ may not be 
a regular polygon.  All labeled points are collinear which implies that the point \f$ c \f$ is visible to \f$ q \f$, that is, 
the segment \f$ bc \f$ is  part of the visibility area \f$ V_q \f$. However, in many cases the user is not interested in 
such low dimensional features that are caused by degeneracies. Also for some algorithms it is actually easier (and more efficient)
to not report this kind of low dimensional features, subsequently called needles. Therefore, this package offers also algorithms 
that compute the regularized visibility area  
\f$ \overline{V_q} = (V_q\setminus\partial V_q) \cup  \partial (V_q\setminus\partial V_q)\f$,
as it is shown in \cgalFigureRef{definition-fig} (2).  For more information about regularization, we also refer to Chapter 
\ref PkgBooleanSetOperations2Summary.

To sum up, this package provides two kinds of visibility region of point \f$ q \f$: 
- Non-regularized visibility area \f$ V_q \f$.
- Regularized visibility area \f$ \overline{V_q} \f$. 


\section visibility_2_classes Classes and Algorithms

CGAL provides three class templates that follow the `Visibility_2` concept:
Class 	                	|	Function                                     |  Preprocessing                |  Query                            |Algorithm
-------------------------------|-----------------------------------------------------|-------------------------------|-----------------------------------|-------------------------------
 `Simple_visibility_2`       | compute visibility in simple polygons                  |       No                     |\f$ O(n) \f$ time and \f$ O(n) \f$ space  | paper of B.Joe and R.B.Simpson \cite bjrb-clvpa-87
 `Rotational_sweep_visibility_2`        |  compute visibility in a polygon with proper holes | No                     | \f$ O(n\log n) \f$ time and \f$ O(n) \f$ space |  paper of T.Asano \cite ta-aeafvpprh-85 
 `Preprocessed_rotational_sweep_visibility_2` | visibility query in a polygon with proper holes       | Yes. \f$ O(n^2) \f$ time and \f$ O(n^2) \f$ space | \f$ O(n) \f$ time and \f$ O(n) \f$ space   | paper of Takao Asano, Tetsuo Asano  etc \cite aaghi-vpsesp-85
`Triangular_expansion_visibility_2`     | visibility query in a polygon with proper holes |  Yes. \f$ O(n^2) \f$ time and \f$ O(n) \f$ space | The worst time is \f$ O(n^2) \f$. Average performance is much better. It works well especially for a polygon that has a lot vertices but is simple locally. It needs \f$ O(n) \f$ space.   | reference is unknown. 

where  \f$ n \f$ is the number of vertices of input polygon.

As the package is based on the \ref PkgArrangement2, a polygonal region is defined as a face within a 'Arrangement_2' of segments, 
which we also refer to as the environment. At this point every visibility class template has two parameters, the `Arrangement_2` class 
and `Regularization_tag`, that is, the user decides at compile time whether the result is computed regularized or not. 

As required by the `Visibility_2` concept, every  class has two overloads of `visibility_region` functions to compute the visibility region of \f$ p \f$ in a bounded polygonal face \f$ F \f$. One is for the case when \f$ p \f$ is in the interior of \f$ F \f$. The other is for the case when \f$ p \f$ is on the boundary of \f$ F \f$. 

\section simple_visibility_example  Example of visibility in a simple polygon.
The following example shows how to obtain the regularized and non-regularized visibility regions and their difference.
\cgalExample{Visibility_2/simple_visibility_2.cpp}

*/

}

//\mainpage 2D Visibility
//\anchor Chapter_2D_Visibility_Computation
//\cgalAutoToc

//\authors Michael Hemmer, Kan Huang, Francisc Bungiu

//\section visibility_2_introduction Introduction

//\cgalFigureBegin{example_figure,visibility-teaser.png}
//An example figure.
//\cgalFigureEnd

//Given a polygonal region \f$ P \f$, which may have holes, and  two points \f$ p \f$ , \f$ q \f$, in general \f$ p \f$ is said to be visible from \f$ q \f$ iff any inner point on segment joining \f$ p \f$ and \f$ q \f$ is "transparent".  The set of points that are visible from \f$ q \f$ is defined as the visibility region of \f$ q \f$.

//\cgalFigureBegin{definition-fig, definition.png}
//\cgalFigureEnd
//Look at \cgalFigureRef{definition-fig}. Part(1) is a polygon \f$ P \f$ with hole \f$ H \f$. The blue polygon apparently is the visibility region of \f$ q \f$ in \f$ P \f$. In some degenerate situations, the definition of visibility is not that clear. For example, in Part(2), \f$ H \f$ shrinks to a segment which is collinear to \f$ q \f$ and vertex \f$ a \f$ moves to the segment joining \f$ q \f$ and \f$ b \f$. As a result, there are two "needles" in the visibility region of \f$ q \f$: \f$ ed \f$ is an inward "needle"; \f$ bc \f$ is an outward one.


//We proceed to define "transparency" so that these "needles" are naturally contained.
//Given a polygon \f$ P \f$, which may have proper holes, degenerate holes(isolated edges and isolated vertices), there are two types of points that is transparent with respect to point \f$ q \f$.
//-  interior of \f$ P \f$.
//-  vertex \f$ v \f$ if \f$ v \f$ is not isolated and all edges incident to \f$ v \f$ is in the same open half plane defined by line \f$ vq \f$ except \f$v\f$ itself.


//The visibility region based on the definition of transparency above is denoted by \f$ V \f$. In many cases the user is just interested in the regularized visibility area \f$ \overline{V} \f$.Also for some algorithms it's actually easier to provide \f$ \overline{V}  \f$ only. Thus, some visibility computation strategies in this package offer to compute the regularized visibility
//area \f$ \overline{V} \f$ directly.

//To sum up, this package provides two kinds of visibility region:
//- Non-regularized visibility area \f$ V \f$.
//- Regularized visibility area \f$ \overline{V} \f$.


//\section visibility_2_classes Classes and Algorithms

//CGAL provides three class templates that follow the `Visibility_2` concept:
//Class 	                	|	Function                                     |  Have Preprocessing                |  Query                            |Algorithm
//-------------------------------|-----------------------------------------------------|-------------------------------|-----------------------------------|-------------------------------
// `Simple_visibility_2`       | compute visibility in simple polygons                  |       No                     |\f$ O(n) \f$ time and \f$ O(n) \f$ space  | paper of B.Joe and R.B.Simpson \cite bjrb-clvpa-87
// `Rotational_sweep_visibility_2`        |  compute visibility in an arbitrary arrangement of segments. | No                     | \f$ O(n\log n) \f$ time and \f$ O(n) \f$ space |  paper of T.Asano \cite ta-aeafvpprh-85


//where  \f$ n \f$ is the number of vertices of input polygon.

//Every templates has two parameters, `Arrangement_2` and `Regularization_tag`. User can attach an instance of `Arrangement_2` as the polygonal environment. `Regularization_tag` indicates whether the result should be regularized or not.

//Each class has two overloads of `visibility_region` functions to compute the visibility region of \f$ p \f$ in a face \f$ F \f$. \f$ F \f$ should be bounded. One function is for case that \f$ p \f$ is in the interior of \f$ F \f$. The other is for case that \f$ p \f$ is on the boundary of \f$ F \f$. The answer is an instance of `Arrangement_2` that consists of edges on the boundary of visibility region.

//\section simple_visibility_example  Example of visibility in a simple polygon.
//\cgalFigureBegin{example1-fig, example1.png}
//\cgalFigureEnd
//The following example shows how to obtain the visibility region of Figure \cgalFigureRef{example1-fig} and the difference between regularized and non-regularized visibility.
//\cgalExample{Visibility_2/simple_visibility_2.cpp}



