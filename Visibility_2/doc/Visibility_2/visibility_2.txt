namespace CGAL {

/*!
\mainpage 2D Visibility  
\anchor Chapter_2D_Visibility_Computation
\cgalAutoToc

\authors Michael Hemmer, Kan Huang, Francisc Bungiu

\cgalFigureBegin{example_figure,visibility-teaser.png}
An example figure. 
\cgalFigureEnd

\section visibility_2_introduction Introduction

This package provides functionality to compute the visibility area within polygonal regions in two dimensions. 
Using the terminology according to \ref PkgBooleanSetOperations2Summary we expect the input polygon  \f$ P \f$ 
to be a valid polygon or a valid polygon with holes, 
that is, we expect \f$ P \f$ to be closed (\f$\partial P \subset P\f$) and each boundary loop 
(only one outer boundary loop in case of no holes) to be relatively simple. 
Given two points \f$ p \f$ and \f$ q \f$ in \f$ P \f$ (defined by a face \f$ f \f$), they are said to be 
visible to each other iff the segment \f$ pq \subset  P \f$, note that \f$\partial P \subset P\f$. 
For a query point \f$ q \in P \f$, the set of points that are visible from \f$ q \f$ is defined as the visibility 
region of \f$ q \f$, denoted by \f$ V_q \f$

\section visibility_2_degeneracies Degeneracies and Regularization 

\cgalFigureBegin{definition-fig, example1.png}
Non-regularized visibility and regularized visibility.
\cgalFigureEnd


As demonstrated in \cgalFigureRef{definition-fig} (1) the visibility region \f$ V_q \f$ of a query point \f$ q \f$ may not be
a valid polygon.  All labeled points are collinear, which implies that the point \f$ c \f$ is visible to \f$ q \f$, that is, 
the segment \f$ bc \f$ is  part of the visibility area \f$ V_q \f$. However, in many cases the user is not interested in 
such low dimensional features that are caused by degeneracies. Also for some algorithms it is actually easier (and more efficient)
to ignore this kind of low dimensional features, subsequently called needles. Therefore, this package offers also implementations algorithms 
that compute the regularized visibility area  
\f$ \overline{V_q} = closure(interior(V_q)) = (V_q\setminus\partial V_q) \cup  \partial (V_q\setminus\partial V_q)\f$,
as it is shown in \cgalFigureRef{definition-fig} (2).  For more information about regularization, we also refer to Chapter 
\ref PkgBooleanSetOperations2Summary.

To sum up, this package provides two kinds of visibility region of point \f$ q \f$: 
- Non-regularized visibility area \f$ V_q \f$.
- Regularized visibility area \f$ \overline{V_q} \f$. 


\section visibility_2_classes Classes and Algorithms

As this package is based on 
the \ref PkgArrangement2Summary package the input is defined by a querry point \f$ q \f$ and by a face \f$ f \f$ 
in an arrangement of segments, where \f$ f \f$ represents a valid polygon, that is, \f$ f \f$ has no isolated vertices 
and each boundary edge of \f$ f \f$ separates \f$ f \f$ from another face. 
As some algorithms are based on a preprocessing step the design is similar 
to the one of point location strategies, that is, before a visibility object can answer a query, it must be 
attached to an arrangement object (subsequently also referred to as the enviroment). 
In particular, not every query must contain the same face of the 
attached arrangement. All provided class templates follow the `Visibility_2` concept:

Class 	                	|	Function                                     |  Preprocessing                |  Query                            |Algorithm
-------------------------------|-----------------------------------------------------|-------------------------------|-----------------------------------|-------------------------------
 `Simple_polygon_visibility_2`       | compute visibility in a valid polygons                  |       No                     |\f$ O(n) \f$ time and \f$ O(n) \f$ space  | paper of B.Joe and R.B.Simpson \cite bjrb-clvpa-87
 `Rotational_sweep_visibility_2`        |  compute visibility in a valid polygon with  holes | No                     | \f$ O(n\log n) \f$ time and \f$ O(n) \f$ space |  paper of T.Asano \cite ta-aeafvpprh-85 
 `Preprocessed_rotational_sweep_visibility_2` | visibility query in a valid polygon with  holes       | \f$ O(n^2) \f$ time and \f$ O(n^2) \f$ space | \f$ O(n) \f$ time and \f$ O(n) \f$ space   | paper of Takao Asano, Tetsuo Asano  etc \cite aaghi-vpsesp-85
`Triangular_expansion_visibility_2`     | visibility query in a valid polygon with  holes |  \f$ O(n^2) \f$ time and \f$ O(n) \f$ space | \f$ O(nh) \f$ time and \f$ O(n) \f$ space.   | reference is unknown. 

Where  \f$ n \f$ and \f$ h \f$ are the numbers  of vertices and holes of the input polygon respectively.

As required by the `Visibility_2` concept, every  class has two overloads of `Visibility_2::visibility_region()` functions to compute the visibility region of \f$ p \f$ in a bounded polygonal face \f$ f \f$: one is for the case when \f$ p \f$ is in the interior of \f$ f \f$; the other one is for the case when \f$ p \f$ is on the boundary of \f$ f \f$. 

\section simple_polygon_visibility_example  Example of visibility in a simple polygon.
The following example shows how to obtain the regularized and non-regularized visibility regions.
\cgalExample{Visibility_2/simple_polygon_visibility_2.cpp}

*/

}

