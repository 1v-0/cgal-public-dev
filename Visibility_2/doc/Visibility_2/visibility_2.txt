namespace CGAL {

/*!
\mainpage 2D Visibility  
\anchor Chapter_2D_Visibility_Computation
\cgalAutoToc

\authors Michael Hemmer, Kan Huang, Francisc Bungiu

\cgalFigureBegin{example_figure,visibility-teaser.png}
\cgalFigureEnd

\section visibility_2_introduction Introduction

This package provides functionality to compute the visibility area within polygonal regions in two dimensions. 
Using the terminology according to \ref PkgBooleanSetOperations2Summary we expect the input polygon  \f$ P \f$ 
to be a valid polygon or a valid polygon with holes, 
that is, we expect \f$ P \f$ to be closed (\f$\partial P \subset P\f$) and each boundary loop 
(only one outer boundary loop in case of no holes) to be relatively simple. 
Given two points \f$ p \f$ and \f$ q \f$ in \f$ P \f$ , they are said to be 
visible to each other iff the segment \f$ pq \subset  P \f$, note that \f$\partial P \subset P\f$. 
For a query point \f$ q \in P \f$, the set of points that are visible from \f$ q \f$ is defined as the visibility 
region of \f$ q \f$, denoted by \f$ V_q \f$

\section visibility_2_degeneracies Degeneracies and Regularization 

\cgalFigureBegin{definition-fig, example1.png}
Non-regularized visibility and regularized visibility.
\cgalFigureEnd


As illustrated in \cgalFigureRef{definition-fig} (1) the visibility region \f$ V_q \f$ of a query point \f$ q \f$ may not be
a valid polygon.  All labeled points are collinear, which implies that the point \f$ c \f$ is visible to \f$ q \f$, that is, 
the segment \f$ bc \f$ is  part of the visibility area \f$ V_q \f$. However, in many cases the user is not interested in 
such low dimensional features that are caused by degeneracies. Also, for some algorithms, it is actually easier (and more efficient)
to ignore this kind of low dimensional features, subsequently called needles. Therefore, this package offers also 
implementations that compute the regularized visibility area  
\f$ \overline{V_q} = closure(interior(V_q)) = (V_q\setminus\partial V_q) \cup  \partial (V_q\setminus\partial V_q)\f$,
as it is shown in \cgalFigureRef{definition-fig} (2).  For more information about regularization, we also refer to Chapter 
\ref PkgBooleanSetOperations2Summary.

To sum up, this package provides two kinds of visibility region of point \f$ q \f$: 
- Non-regularized visibility area \f$ V_q \f$.
- Regularized visibility area \f$ \overline{V_q} \f$. 


\section visibility_2_classes Classes and Algorithms

This package is based on 
the \ref PkgArrangement2Summary package and exploits several of its features. Given a query point \f$ q \f$ and a face \f$ f \f$ 
in an arrangement of segments, where \f$ f \f$ represents a valid polygon, that is, \f$ f \f$ has no isolated vertices 
and each boundary edge of \f$ f \f$ separates \f$ f \f$ from another face, find the visibility region \f$ V_q \f$ represented by a (separate) arrangement. 
Answering visibility queries is, in many ways, similar to answering point-location queries. Thus, we use the same design used to implement point location. Each of the various visibility class templates employs a different algorithm or \em strategy \cgalFootnote{The term \em strategy is borrowed from the design-pattern taxonomy~\cite ghjv-dpero-95. A \em strategy provides the means to define a family of algorithms, each implemented by a separate class. All classes that implement the various algorithms are made interchangeable, letting the algorithm in use vary according to the user choice.} for answering queries. Similar to the point-location case, some of the strategies requires preprocessing. Thus, before a visibility object is used to answer visibility queries, it must be attached to an arrangement object (subsequently also referred to as the environment).
In particular, different query points can be in different faces of the 
associated  arrangement. All provided class templates follow the `Visibility_2` concept:

Class 	                	|	Function                                     |  Preprocessing                |  Query                            |Algorithm
-------------------------------|-----------------------------------------------------|-------------------------------|-----------------------------------|-------------------------------
 `Simple_polygon_visibility_2`       | compute visibility in a valid polygons                  |       No                     |\f$ O(n) \f$ time and \f$ O(n) \f$ space  | paper of B.Joe and R.B.Simpson \cite bjrb-clvpa-87
 `Rotational_sweep_visibility_2`        |  compute visibility in a valid polygon with  holes | No                     | \f$ O(n\log n) \f$ time and \f$ O(n) \f$ space |  paper of T.Asano \cite ta-aeafvpprh-85 
`Triangular_expansion_visibility_2`     | visibility query in a valid polygon with  holes |  \f$ O(n) \f$ time and \f$ O(n) \f$ space | \f$ O(nb) \f$ time and \f$ O(n) \f$ space.   | reference is unknown. 
 `Preprocessed_rotational_sweep_visibility_2` | visibility query in a valid polygon with  holes       | \f$ O(n^2) \f$ time and \f$ O(n^2) \f$ space | \f$ O(n) \f$ time and \f$ O(n) \f$ space   | paper of Takao Asano, Tetsuo Asano  etc \cite aaghi-vpsesp-85

Where  \f$ n \f$ is the number of vertices of \f$ f \f$ and \f$ b \f$ is the number of boundaries of \f$ f \f$, including outer boundary and inner boundaries(holes); \f$ b \f$ can be as big as \f$ \Theta(n) \f$ and for simple polygons, \f$ b \f$ is \f$ 1 \f$.

Every model of the Visibility_2 concept must provide two overloaded member functions, called `Visibility_2::visibility_region()` functions, that compute the visibility region of \f$ p \f$ in a bounded polygonal face \f$ f \f$: one is for the case where \f$ p \f$ is in the interior of \f$ f \f$; the other one is for the case where \f$ p \f$ is on the boundary of \f$ f \f$. 

\section simple_polygon_visibility_example  Example of Visibility in a Simple Polygon
The following example shows how to obtain the regularized and non-regularized visibility regions.
\cgalExample{Visibility_2/simple_polygon_visibility_2.cpp}
\cgalFigureBegin{simple_example, simple_example.png}
Two different visibility regions in the example above.
\cgalFigureEnd

*/

}

