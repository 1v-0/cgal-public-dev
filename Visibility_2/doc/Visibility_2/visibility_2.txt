namespace CGAL {

/*!
\mainpage 2D Visibility  
\anchor Chapter_2D_Visibility_Computation
\cgalAutoToc

\authors Michael Hemmer, Kan Huang, Francisc Bungiu, Ning Xu

\cgalFigureBegin{example_figure,visibility-teaser.png}
\cgalFigureEnd

\section visibility_2_introduction Introduction

This package provides functionality to compute the visibility region within polygonal regions in two dimensions. 
Using the terminology of the package \ref PkgBooleanSetOperations2Summary, we expect the input polygon  
\f$ P \f$ to be a valid polygon or a valid polygon with holes (the definition is given below). 
Given two points \f$ p \f$ and \f$ q \f$ in \f$ P \f$, they are said to be 
visible to each other iff the segment \f$ pq \subset  P \f$, note that \f$\partial P \subset P\f$. 
For a query point \f$ q \in P \f$, the set of points that are visible from \f$ q \f$ is defined as the visibility 
region of \f$ q \f$, denoted by \f$ V_q \f$


Definition [Valid Polygon]: 
A polygon \f$ P \f$ is valid if  \f$ P \f$ is closed (\f$\partial P \subset P\f$) 
and each boundary loop (only one outer boundary loop in case of no holes) is simple. 
See also \ref PkgBooleanSetOperations2Summary. 


\subsection visibility_2_degeneracies Degeneracies and Regularization 

\cgalFigureBegin{definition-fig, example1.png}
Non-regularized visibility and regularized visibility.
\cgalFigureEnd


As illustrated in \cgalFigureRef{definition-fig} (1) the visibility region \f$ V_q \f$ of a query point \f$ q \f$ may not be
a valid polygon.  In the figure, all labeled points are collinear, which implies that the point \f$ c \f$ is visible to \f$ q \f$, that is, 
the segment \f$ bc \f$ is  part of the visibility area \f$ V_q \f$. 
Subsequently we call such low dimensional features that are caused by degeneracies `needles`. 
However, for many applications these needles are actually irrelevant. 
Moreover, for some algorithms it is actually easier (and more efficient) to ignore needles 
in the first place. 
Therefore, this package offers also 
functionality to compute the regularized visibility area  
\f$ \overline{V_q} = closure(interior(V_q)) = (V_q\setminus\partial V_q) \cup  \partial (V_q\setminus\partial V_q)\f$,
as it is shown in \cgalFigureRef{definition-fig} (2).  For more information about regularization, refer to Chapter 
\ref PkgBooleanSetOperations2Summary.

In summary, this package provides two kinds of visibility region of point \f$ q \f$: 
- Non-regularized visibility area \f$ V_q \f$.
- Regularized visibility area \f$ \overline{V_q} \f$. 


\section visibility_2_classes Classes and Algorithms

This package is based on the \ref PkgArrangement2Summary package and exploits several of its features. 
In particular, the output is represented by an `Arrangement_2`, which enables
the representation of needles. All provided class templates follow the `Visibility_2` concept. 

Answering visibility queries is, in many ways, similar to answering point-location queries. Thus, we use the same design used 
to implement point location. Each of the various visibility class templates employs a different algorithm or \em strategy 
\cgalFootnote{The term \em strategy is borrowed from the design-pattern taxonomy~\cite ghjv-dpero-95. A \em strategy provides 
the means to define a family of algorithms, each implemented by a separate class. All classes that implement the various 
algorithms are made interchangeable, letting the algorithm in use vary according to the user choice.} for answering queries. 
Similar to the point-location case, some of the strategies require preprocessing. Thus, before a visibility object is used
to answer visibility queries, it must be attached to an arrangement object (subsequently also referred to as the environment).
Afterwards the visibility object observers changes to the attached arrangement. 
Clearly, it is possible to modify the arrangement after attaching the visibility object. 
However, this should be avoided as this also requires an update of the auxiliary 
data structures in the attached object. 

An actual query is then performed by giving the view point \f$ p \f$ and its containing face \f$ f \f$, 
which must represent a valid \cgalFootnote{See the package \ref PkgBooleanSetOperations2Summary for precise definition}
polygon (\f$ f \f$ has no isolated vertices and each boundary edge of \f$ f \f$ separates it from another face). 
For this purpose every model of the Visibility_2 concept provides two overloaded member functions, called `Visibility_2::compute_visibility()` 
functions, that compute the visibility region of \f$ p \f$ in a bounded polygonal face \f$ f \f$: one is for the case where 
\f$ p \f$ is in the interior of \f$ f \f$; the other one is for the case where \f$ p \f$ is on the boundary of \f$ f \f$. 


The package provides the following models of the `Visibility_2` concept:

Class 	                	|	Function                                     |  Preprocessing                |  Query                            |Algorithm
-------------------------------|-----------------------------------------------------|-------------------------------|-----------------------------------|-------------------------------
 `Simple_polygon_visibility_2`       | simple valid polygons                  |       No        |\f$ O(n) \f$ time and \f$ O(n) \f$ space  | B.Joe and R.B.Simpson \cite bjrb-clvpa-87
 `Rotational_sweep_visibility_2`        |  valid polygons with holes | No                     | \f$ O(n\log n) \f$ time and \f$ O(n) \f$ space |  T.Asano \cite ta-aeafvpprh-85 
`Triangular_expansion_visibility_2`     |  valid polygons with  holes |  \f$ O(n) \f$ time and \f$ O(n) \f$ space | \f$ O(nh) \f$ time and \f$ O(n) \f$ space.   | new


Where  \f$ n \f$ is the number of vertices of \f$ f \f$ and \f$ h \f$ is the number of holes+1.

\section benchmarks Runtime in Practice 

\cgalFigureBegin{cathedral-fig, cathedral_2.png}
Example environment representing a cathedral. 
\cgalFigureEnd

The left hand side of Figure \cgalFigureRef{cathedral-fig} depicts the outer boundary of a cathedral,
which is a simple polygon with 565 vertices. The right hand side shows the cathedral also with its inner 
pillars, which is a polygon with 1153 vertices. The following table shows the total runtime to compute 
all visibility polygons for all vertices of the boundary of the cathedral. 


Boundary Cathedral  	       |	total preprocessing time | total query time  |  
-------------------------------|-----------------------------------------------------|-------------------------------|
 `Simple_polygon_visibility_2`                |  - |  0.38 | 
 `Rotational_sweep_visibility_2`              |  - |  1.01  |  
`Triangular_expansion_visibility_2`           |  0.01 |  0.06 |  

The second table shows the same for the complete cathedral. The table does not report the time for `Simple_polygon_visibility_2`
as this algorithm can only handle simple polygons. 

Complete Cathedral             |	total preprocessing time | total query time          | 
-------------------------------|-----------------------------------------------------|-------------------------------|
 `Rotational_sweep_visibility_2`              |  -          | 1.91   |  
 `Triangular_expansion_visibility_2`          |  0.01   | 0.04  |  

Thus, in general we recommend to use `Triangular_expansion_visibility_2` even if the polygon is simple. The main advantage 
of the algorithm is its locality. After the triangle that contains the query point is located in the triangulation, 
the algorithm explores neighboring triangles, but only those that are actually seen. In this sense the algorithm can be 
considered as output sensitive. However, if the simple polygon is rather convex (i.e., nearly all boundary is seen) or 
if only one (or very little) queries are required, using one of the algorithms that does not require preprocessing is advantageous. 


\section simple_polygon_visibility_example  Example of Visibility in a Simple Polygon
The following example shows how to obtain the regularized and non-regularized visibility regions.
\cgalExample{Visibility_2/simple_polygon_visibility_2.cpp}

\section general_polygon_example Example of Visibility in a Polygon with Holes
The following example shows how to obtain the regularized visibility region using the model `Triangular_expansion_visibility_2`. See \cgalFigureRef{general_polygon}. The arrangement has six bounded faces and an unbounded face. The query point \f$ q \f$ is on a vertex. The red arrow denotes the halfedge \f$ \overrightarrow{pq} \f$, which also identifies the face in which the visibility region is computed.
\cgalFigureBegin{general_polygon, general_polygon_example.png}
The visibility region of \f$ q \f$ in a polygon with two holes.
\cgalFigureEnd
\cgalExample{Visibility_2/general_polygon_example.cpp}

\section implentation_history Implementation History

This package was first developed during Google Summer of Code 2013. Fancisc Bungju developed the Simple_polygon_visibility_2 class; Kan Huang developed the Rotational_sweep_visibility_2 class; and Michael Hemmer developed the Triangular_expansion_visibility_2 class.

This first class, Simple_polygon_visibility_2, implements the algorithm presented by B. Joe and R.B. Simpson in 1987 \cite js-clvpa87. This algorithm is a linear time algorithm for simple polygons, fixing the errors in a previous algorithm presented by D.T. Lee in 1983.

The second class, Rotational_sweep_visibility_2, implements the algorithm presented by T. Asano in 1985. This algorithm can be applied to polygons with holes with time complexity \f$ O(n\log n) \f$.

The third class, Triangular_expansion_visibility_2, implements the algorithm presented by F. Bungju, et al.. This algorithm can be applied to polygons with holes with worst case running time \f$ O(n^2) \f$, but is extremely fast in practice.

In Google Summer of Code 2014, Ning Xu became a developer for this package. He fixed bugs in the algorithm for simple polygons.

*/

}

// `Preprocessed_rotational_sweep_visibility_2` | valid polygons with holes    | \f$ O(n^2) \f$ time and \f$ O(n^2) \f$ space | \f$ O(n) \f$ time and \f$ O(n) \f$ space   | Takao Asano, Tetsuo Asano  etc \cite aaghi-vpsesp-85
